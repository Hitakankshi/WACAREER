/**
 * @file Firestore Security Rules for Royal Ascent Careers Platform
 * @description This ruleset enforces a strict user-ownership model for personal data while allowing public read access to job postings and courses.
 *
 * Core Philosophy:
 *  - Strict user ownership for data under `/users/{userId}`. Only the authenticated user can read or write their own data.
 *  - Job postings and internships are publicly readable but only writable by authorized roles (to be defined later).
 *  - Course access is controlled via a "members" map on the course document, enabling collaborative access.
 *  - Admin privileges are granted based on document existence in `/roles_admin/{userId}`.
 *
 * Data Structure:
 *  - `/users/{userId}`: Stores private user profile information.
 *  - `/roles_admin/{userId}`: Indicates admin status; document existence grants admin privileges.
 *  - `/job_postings/{jobPostingId}`: Publicly readable job postings. Write access needs to be implemented based on roles and will be added.
 *  - `/internship_opportunities/{internshipId}`: Publicly readable internship opportunities. Write access needs to be implemented based on roles and will be added.
 *  - `/courses/{courseId}`: Stores course information; access is managed via the `members` map.
 *  - `/courses/{courseId}/students/{userId}`: list the course students
 *  - `/users/{userId}/applications/{applicationId}`: Stores job/internship applications submitted by users.
 *
 * Key Security Decisions:
 *  - User listing is disabled for the `/users` collection to prevent unauthorized access to user data.
 *  - Ownership is enforced based on the `userId` path parameter.
 *  - The `members` map on courses denormalizes access control, avoiding costly `get()` calls.
 *
 * Denormalization for Authorization:
 *  - The `members` map on `/courses/{courseId}` allows for efficient access control without needing to fetch user profile data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @return {boolean} True if the request is authenticated, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the authenticated user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource and that the resource exists.
     * @param {string} userId The user ID to compare against the authenticated user's ID.
     * @return {boolean} True if the authenticated user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user has admin privileges based on document existence.
     * @return {boolean} True if the authenticated user is an admin, false otherwise.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * @description Rule for /users/{userId} collection.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates a new profile: request.auth.uid == 'user123'
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes their own profile: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user456' tries to create a profile for 'user123': request.auth.uid != 'user123'
     * @deny (get, update, delete) User with ID 'user456' tries to read/update/delete 'user123' profile: request.auth.uid != 'user123'
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Rule for /roles_admin/{userId} collection.
      * @path /roles_admin/{userId}
      * @allow (create) User with ID 'admin123' creates their admin role: request.auth.uid == 'admin123'
      * @allow (get, update, delete) User with ID 'admin123' reads/updates/deletes their admin role: request.auth.uid == 'admin123'
      * @deny (create) User with ID 'user456' tries to create admin role for 'admin123': request.auth.uid != 'admin123'
      * @deny (get, update, delete) User with ID 'user456' tries to read/update/delete 'admin123' admin role: request.auth.uid != 'admin123'
      * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
      */
     match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if false; // Admin listing is not permitted.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule for /job_postings/{jobPostingId} collection.
     * @path /job_postings/{jobPostingId}
     * @allow (get, list) Any user can read/list job postings.
     * @deny (create, update, delete) Non-admin user tries to create/update/delete job postings.
     * @principle Allows public read access but restricts write access to authorized users.
     */
    match /job_postings/{jobPostingId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rule for /internship_opportunities/{internshipId} collection.
     * @path /internship_opportunities/{internshipId}
     * @allow (get, list) Any user can read/list internship opportunities.
     * @deny (create, update, delete) Non-admin user tries to create/update/delete internship opportunities.
     */
    match /internship_opportunities/{internshipId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rule for /courses/{courseId} collection.
     * @path /courses/{courseId}
     * @allow (get, list) Any user can read/list courses.
     * @allow (create, update, delete) Only admin users can create, update and delete courses
     */
    match /courses/{courseId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rule for /courses/{courseId}/students/{userId} collection.
     * @path /courses/{courseId}/students/{userId}
     * @allow (get, list) Any user can read/list student in course
     * @deny (create, update, delete) Non-admin user tries to create/update/delete student in course.
     */
    match /courses/{courseId}/students/{userId} {
      allow get, list: if true;
      allow create, update, delete: if isAdmin();
    }

    /**
     * @description Rule for /users/{userId}/applications/{applicationId} collection.
     * @path /users/{userId}/applications/{applicationId}
     * @allow (create) User with ID 'user123' creates a new application: request.auth.uid == 'user123'
     * @allow (get, update, delete) User with ID 'user123' reads/updates/deletes their own application: request.auth.uid == 'user123'
     * @deny (create) User with ID 'user456' tries to create an application for 'user123': request.auth.uid != 'user123'
     * @deny (get, update, delete) User with ID 'user456' tries to read/update/delete 'user123' application: request.auth.uid != 'user123'
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId}/applications/{applicationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}